<GENERATED-CODE>
1. Update existing file chain.go to enhance the timeout log message for clarity regarding background execution.
2. Create new file example_chain_test.go to demonstrate the preferred pattern: a Job that handles its own cancellation via Context.

<UPDATED_EXISTING_FILE: chain.go>
package cron

import (
	"fmt"
	"runtime"
	"sync"
	"time"
)

// JobWrapper decorates the given Job with some behavior.
type JobWrapper func(Job) Job

// Chain is a sequence of JobWrappers that decorates submitted jobs with
// cross-cutting behaviors like logging or synchronization.
type Chain struct {
	wrappers []JobWrapper
}

// NewChain returns a Chain consisting of the given JobWrappers.
func NewChain(c ...JobWrapper) Chain {
	return Chain{c}
}

// Then decorates the given job with all JobWrappers in the chain.
//
// This:
//
//	NewChain(m1, m2, m3).Then(job)
//
// is equivalent to:
//
//	m1(m2(m3(job)))
func (c Chain) Then(j Job) Job {
	for i := range c.wrappers {
		j = c.wrappers[len(c.wrappers)-i-1](j)
	}
	return j
}

// Recover panics in wrapped jobs and log them with the provided logger.
func Recover(logger Logger) JobWrapper {
	return func(j Job) Job {
		return FuncJob(func() {
			defer func() {
				if r := recover(); r != nil {
					const size = 64 << 10
					buf := make([]byte, size)
					buf = buf[:runtime.Stack(buf, false)]
					err, ok := r.(error)
					if !ok {
						err = fmt.Errorf("%v", r)
					}
					logger.Error(err, "panic", "stack", "...\n"+string(buf))
				}
			}()
			j.Run()
		})
	}
}

// DelayIfStillRunning serializes jobs, delaying subsequent runs until the
// previous one is complete. Jobs running after a delay of more than a minute
// have the delay logged at Info.
func DelayIfStillRunning(logger Logger) JobWrapper {
	return func(j Job) Job {
		var mu sync.Mutex
		return FuncJob(func() {
			start := time.Now()
			mu.Lock()
			defer mu.Unlock()
			if dur := time.Since(start); dur > time.Minute {
				logger.Info("delay", "duration", dur)
			}
			j.Run()
		})
	}
}

// SkipIfStillRunning skips an invocation of the Job if a previous invocation is
// still running. It logs skips to the given logger at Info level.
func SkipIfStillRunning(logger Logger) JobWrapper {
	return func(j Job) Job {
		ch := make(chan struct{}, 1)
		ch <- struct{}{}
		return FuncJob(func() {
			select {
			case v := <-ch:
				defer func() { ch <- v }()
				j.Run()
			default:
				logger.Info("skip")
			}
		})
	}
}

// Timeout wraps a job with a timeout. If the job takes longer than the given
// duration, the wrapper returns and logs an error, but the underlying job
// goroutine continues running until completion.
//
// WARNING: This implements an "abandonment model" - when a timeout occurs,
// the wrapper returns but the job's goroutine is NOT canceled. The job will
// continue executing in the background until it naturally completes. This means:
//   - Resources held by the job will not be released until completion
//   - Side effects will still occur even after timeout
//   - Multiple abandoned goroutines can accumulate if jobs consistently timeout
//
// For jobs that need true cancellation support, consider implementing the Job
// interface with context awareness and checking for cancellation signals.
//
// A timeout of zero or negative disables the timeout and returns the job unchanged.
func Timeout(logger Logger, timeout time.Duration) JobWrapper {
	return func(j Job) Job {
		if timeout <= 0 {
			return j
		}
		return FuncJob(func() {
			done := make(chan struct{})
			var panicVal interface{}
			go func() {
				defer close(done)
				defer func() {
					if r := recover(); r != nil {
						panicVal = r
					}
				}()
				j.Run()
			}()

			timer := time.NewTimer(timeout)
			defer timer.Stop()

			select {
			case <-done:
				// Job completed within timeout - propagate any panic
				if panicVal != nil {
					panic(panicVal)
				}
			case <-timer.C:
				// Log explicit warning about abandonment
				logger.Error(fmt.Errorf("job exceeded timeout of %v; continuing in background", timeout), "timeout", "duration", timeout)
			}
		})
	}
}
</UPDATED_EXISTING_FILE>

<NEWFILE: example_chain_test.go>
package cron_test

import (
	"context"
	"fmt"
	"time"

	"github.com/robfig/cron/v3"
)

// OneOfTheGoodOnes demonstrates how to implement a Job that handles
// cancellation properly using context.Context.
//
// Unlike the Timeout wrapper, which abandons running jobs in the background,
// this pattern allows the job to clean up resources and exit cleanly when
// a timeout or cancellation signal is received.
type OneOfTheGoodOnes struct{}

func (j OneOfTheGoodOnes) Run() {
	// 1. Create a context with a timeout
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
	defer cancel()

	// 2. Pass the context to your long-running logic
	j.doWork(ctx)
}

func (j OneOfTheGoodOnes) doWork(ctx context.Context) {
	select {
	case <-time.After(2 * time.Second):
		fmt.Println("Work completed (unexpected)")
	case <-ctx.Done():
		// 3. Handle cancellation cleanly
		fmt.Println("Work cancelled:", ctx.Err())
	}
}

func ExampleTimeout_cancellable() {
	// This example shows how a properly implemented job handles its own timeout.
	// The job itself enforces the 1-second limit defined in its Run method.
	
	job := OneOfTheGoodOnes{}
	job.Run()

	// Output:
	// Work cancelled: context deadline exceeded
}

// ExampleTimeout_wrapper shows the behavior of the wrapper approach.
// Note that while the wrapper returns after 1ms, the job finishes printing
// later because it was abandoned, not cancelled.
func ExampleTimeout_wrapper() {
	c := cron.New()
	
	// Create a job that takes 100ms
	slowJob := cron.FuncJob(func() {
		time.Sleep(100 * time.Millisecond)
	})

	// Wrap it with a 1ms timeout
	// This will log an error: "job exceeded timeout...; continuing in background"
	c.AddJob("@every 1s", cron.NewChain(cron.Timeout(cron.DefaultLogger, 1*time.Millisecond)).Then(slowJob))
}
</NEWFILE>
</GENERATED-CODE>
